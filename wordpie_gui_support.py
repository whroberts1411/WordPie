#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#-------------------------------------------------------------------------------
# Name:         wordpie_gui_support.py
#
# Purpose:      Main GUI screen for a Python Wordle word game. The program
#               caters for three different modes of play :
#
#               1] Manual - the program picks a secret word and the user tries
#                  to guess what it is.
#               2] Auto - the program picks a secret word, and the code then
#                  tries to find out what it was, populating the grid
#                  automatically.
#               3] Other - the words are picked by the computer, and entered
#                  into a grid generated by the Wordle program on its website.
#                  The user than enters the colours generated for the guess in
#                  this program, and continues until (hopefully) the word is
#                  found.
#
# Author:       Bill Roberts
#
# Created:      Wednesday 19th January 2022
#
# Amended:      02/02/2022
#               Add an additional check for auto completion, so that each new
#               word selected contains the letters that were not in the
#               correct position, as well as those that were.
#               14/02/2022
#               Amend the screen layout and processing to match more closely to
#               the online version. A keyboard has been added, and the way that
#               letters are entered has changed.
#               21/02/2022
#               When solving a puzzle from another source (e.g. web), highlight
#               the current letter when adding the background colours.
#               02/03/2022
#               Add key bindings for <Ctrl> + 'h' or 'd' sequences. These will
#               action events that aren't relly appropriate for conventional
#               buttons (print a hint to the console and turn debug on/off).
#
#-------------------------------------------------------------------------------

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from tkinter import messagebox
import string

import wordpie_gui
import wordpie

# Colours for the letter and button backgrounds
green = "#c9fb96"
gold = "#deea07"
grey = "#C6D8D8"
white = '#ffffff'
blue = '#0000e1'        # this is the text colour for the guesses
btnColour = "#fffaf0"   # this is the default pale yellow colour
btnDisabled = '#c9c9c9' # The light grey used for the main window background

# This is the word we need to find
secret = ''
# Storage for possible letters at each word position (as sets)
letterSets = []
# Set of correct letters in the wrong position
wrongPos = set()
# Print messages to the terminal for matches and other debug info?
debug = False
# Current word and letter in the guesses grid
curr_word = None
curr_letter = None
# Store textbox controls for the grid - 6 sublists, one per row
wordGrid = []
# Store the textbox variables for the grid - 6 sublists, one per row
varsGrid = []
# Dictionary to store the keyboard button controls - key is the letter
keyboard = {}

#-------------------------------------------------------------------------------
# Event Handlers for the screen controls, etc.
#-------------------------------------------------------------------------------

def cmdStart_click(*args):
    """ Start a new WordPie game. Clear the word fields and get a new word
        from the dictionary.   """

    init_screen()

    global secret
    secret = wordpie.getSecretWord(debug).lower()

    # check the option, and run auto-solve or other if required
    if _w1.ManAuto.get() == 'Aut':
        autoSolve()
    elif _w1.ManAuto.get() == 'Oth':
        setSidePanel(True)
        solvePuzzle()
    else:
        enableKeyboard()

#-------------------------------------------------------------------------------

def cmdKeyboard_click(*args):
    """ This handles the keyboard keys at the bottom of the screen. The arg[0]
        parameter holds the letter value of the key clicked.  """

    global curr_word, curr_letter

    letter = args[0]

    # Is it the end of the current word?
    if curr_letter > 4: return

    # Enter the letter in the grid and increment the letter position
    varsGrid[curr_word][curr_letter].set(letter)
    curr_letter += 1

#-------------------------------------------------------------------------------

def cmdDelete_click(*args):
    """ The Delete key on the on-screen keyboard. Delete the last-entered
        letter in the current word. """

    global curr_word, curr_letter

    if curr_letter > 0 : curr_letter -= 1
    varsGrid[curr_word][curr_letter].set('')

#-------------------------------------------------------------------------------

def cmdEnter_click(*args):
    """ The Enter key on the on-screen keyboard. Check the word in the
        current row against the secret word, and adjust the background
        colours accordingly. Also do the keyboard colours.  """

    global curr_word, curr_letter

    # Get the word from the current line for checking
    word = ''
    for letter in varsGrid[curr_word]:
        word += letter.get()

    # If valid, check against the dictionary and colour as appropriate
    if isValid(word, curr_word+1):
        checkWord(word, wordGrid[curr_word], curr_word+1)
        if curr_word < 5:
            curr_word += 1
            curr_letter = 0
        else:
            disableKeyboard()

#-------------------------------------------------------------------------------

def cmdExit_click(*args):
    """ Close the application """

    root.destroy()

#-------------------------------------------------------------------------------

def vcmd(*args):
    """ Validate the entries in the letter fields to be letters only, and
        single characters. Cater for the backspace key.   """

    for arg in args:
        if len(arg) == 0: return True       # allow the Backspace key
        if not arg.isalpha(): return False  # Limit to alphabetics
        if len(arg) > 1: return False       # limit to a single character
    return True

#-------------------------------------------------------------------------------

def cmdGold_click(*args):
    """ Set the current letter's background to gold (for solving puzzles on
        other machines/web).  """

    setLetterColour(gold)

#-------------------------------------------------------------------------------

def cmdGray_click(*args):
    """ Set the current letter's background to gray (for solving puzzles on
        other machines/web).  """

    setLetterColour(grey)

#-------------------------------------------------------------------------------

def cmdGreen_click(*args):
    """ Set the current letter's background to green (for solving puzzles on
        other machines/web).  """

    setLetterColour(green)

#-------------------------------------------------------------------------------

def cmdNext_click(*args):
    """ Get the next word when solving a game from an external site or on
        another machine.   """

    global curr_word

    # The colours have been set, so adjust to the letterSets. If any errors, or
    # the grid has been completed, finish.
    if not updateFoundLetters(curr_word): return

    curr_word += 1
    if curr_word > 5:
        setSidePanel(False)
        return
    else:
        solvePuzzle()

#-------------------------------------------------------------------------------

def key_pressed(event):
    """ Capture specific <Ctrl>-key sequences, to perform actions that we
        don't want to assign to buttons. """

    global debug

    # If <Ctrl>-h is pressed, select a random word from the word list as a hint
    # for the player. It will be displayed in the console window.
    if event.keysym == 'h':
        hint = wordpie.getHint()
        print(hint)

    # Turn debug mode on or off if <Ctrl>-d is pressed.
    if event.keysym == 'd':
        debug = not debug
        print('Debug is', debug)

#-------------------------------------------------------------------------------
# Miscellaneous helper functions called from screen controls, etc.
#-------------------------------------------------------------------------------

def isValid(word, attempt):
    """ Validate the word that has been entered. It must be five characters in
        length, and present on the word dictionary - i.e. it must be a proper
        word, not just a sequence of letters. If a 'proper' word is rejected,
        there's an option to add it to the dictionary.  """

    msg = ''

    # Must be exactly five letters
    word = word.lower()
    if len(word) != 5 :
        msg = 'All five letters must be entered.\n'
        messagebox.showerror('Invalid Word Entered', 'Word Number ' +
                                str(attempt) + '\n' + msg)

    # Must be a valid word from the dictionary
    elif not wordpie.wordFound(word):
        quest = 'Do you want to add this word to the dictionary? (' + word + ')'
        res = messagebox.askyesno('Word Not In The Dictionary', quest)
        if not res:
            msg = 'This is not a valid word, try again.\n'
            messagebox.showerror('Invalid Word Entered', msg)
        else:
            wordpie.addNewWord(word)

    # Return the result of the validation
    if msg != '':
        return False
    else:
        return True

#-------------------------------------------------------------------------------

def checkWord(word, letters, attempt=0):
    """ Check the word that's been entered against the secret word, and set the
        background colours of the appropriate letter controls and keyboard
        buttons.   """

    # Set the appropriate background colours
    word = word.lower()
    for idx in range(5):
        if word[idx] == secret[idx]:
            letters[idx].configure(disabledbackground=green)
            letterSets[idx] = {word[idx]}
            setKey(word[idx], green)
        elif word[idx] in secret:
            letters[idx].configure(disabledbackground=gold)
            setKey(word[idx], gold)
            wrongPos.add(word[idx])
            try:
                letterSets[idx].remove(word[idx])
            except KeyError:
                pass
        else:
            letters[idx].configure(disabledbackground=grey)
            setKey(word[idx], grey)
            for temp in letterSets:
                try:
                    temp.remove(word[idx])
                except KeyError:
                    pass

    # Set the label message, depending on what's happened
    if word == secret:
        msg = "You've Won! The secret word was " + secret
        disableKeyboard()
    elif attempt == 6:
        msg = "You've Lost. The secret word was " + secret
        disableKeyboard()
    else:
        msg = ''
    _w1.lblMessage.config(text=msg)

#-------------------------------------------------------------------------------

def setKey(letter, colour):
    """ Set the keyboard key corresponding to 'letter' to the requested
        colour. If currently set to green, do not reset to gold.  """

    button = keyboard[letter]
    curr = button.cget('bg')
    if curr != green:
        button.config(background=colour)

#-------------------------------------------------------------------------------

def autoSolve():
    """ Get the computer to guess the secret word (generated by this program,
        taken at random from the dictionary). In a test, the program failed to
        guess the correct word in 10 games out of 269. The number of correct
        games in a row varied from 4 to 98. Just over 96% success rate.  """

    # get the candidate words from the dictionary and fill them in
    for idx in range(1,7):
        if idx == 1:
            word = wordpie.getBestWord(debug)
        else:
            word = wordpie.getNextWord(letterSets, wrongPos, debug)
        displayWord(idx, word, True)
        cmdEnter_click()
        if word == secret: return

#-------------------------------------------------------------------------------

def solvePuzzle():
    """ This is a semi-automated function to solve a Wordle puzzle generated
        by another program. The words are manually entered in that program,
        and we duplicate the entries here for this machine to work out. It does
        sometimes fail, as our word list isn't exactly the same as the official
        Wordle one - and the program doesn't always get it right, anyway.  """

    global curr_word, curr_letter

    curr_letter = 0
    if curr_word == 0:
        word = wordpie.getBestWord(debug)
    else:
        word = wordpie.getNextWord(letterSets, wrongPos, debug)
    displayWord(curr_word+1, word, False)

    if word == 'ERROR':
        msg = "Something's gone wrong.\n We can't find a matching word "
        msg += "in our word list.\n Maybe you added the wrong colours?"
        messagebox.showerror('Word Not Found', msg)
        setSidePanel(False)
        return

#-------------------------------------------------------------------------------

def displayWord(pos, word, auto):
    """ Display the supplied word in the appropriate row. The supplied 'pos'
        value is the row number on the screen, and thus starts from 1, so need
        to subtract one to use it as a list index.  """

    pos -= 1
    for idx in range(0,5): varsGrid[pos][idx].set(word[idx])

    # Highlight the first letter in the word with a red border
    if word != 'ERROR' and not auto:
        wordGrid[pos][0].configure(highlightthickness=1)

#-------------------------------------------------------------------------------

def setLetterColour(colour):
    """ Set the background colour of the current letter. Un-highlight the
        current letter, and highlight the next one in sequence.  """

    global curr_letter
    if curr_letter > 4: return
    wordGrid[curr_word][curr_letter].configure(disabledbackground=colour,
                                                highlightthickness=0)
    curr_letter += 1
    if curr_letter < 5:
        wordGrid[curr_word][curr_letter].configure(highlightthickness=1)

#-------------------------------------------------------------------------------

def updateFoundLetters(wordRow):
    """ Update the letterSets depending on the background colours of the
        letters. Used only when solving Wordle games from the web, etc. """

    global letterSets, wrongPos

    ok = True
    correct = 0

    for idx, letter in enumerate(wordGrid[wordRow]):
        letterVal = letter.get()
        if letter.cget('disabledbackground') == green:
            letterSets[idx] = {letterVal}
            correct += 1
        elif letter.cget('disabledbackground') == gold:
            wrongPos.add(letterVal)
            try:
                letterSets[idx].remove(letterVal)
            except KeyError:
                pass
        elif letter.cget('disabledbackground') == grey:
            for temp in letterSets:
                try:
                    temp.remove(letterVal)
                except KeyError:
                    pass
        else:
            msg = 'You must add colour to each letter in the word\n'
            msg += 'before getting the next word to try.'
            messagebox.showerror('Incomplete Entries', msg)
            ok = False
            break

    if correct == 5:
        _w1.lblMessage.config(text='You found it!')
        setSidePanel(False)
        ok = False

    return ok

#-------------------------------------------------------------------------------
# Housekeeping functions for Page and the screen display
#-------------------------------------------------------------------------------

def disableKeyboard():
    """ Disable the keyboard keys before a game is started, and when a game has
        completed - either when we run out of guesses or we have won.  """

    _w1.cmdEnter['state'] = 'disable'
    _w1.cmdDelete['state'] = 'disable'

    for key, button in keyboard.items():
        button['state'] = 'disable'

#-------------------------------------------------------------------------------

def enableKeyboard():
    """ Enable the keyboard when a game is started (but only manual mode).  """

    _w1.cmdEnter['state'] = 'normal'
    _w1.cmdDelete['state'] = 'normal'

    for key, button in keyboard.items():
        button['state'] = 'normal'

#-------------------------------------------------------------------------------

def setSidePanel(enable):
    """ Enable or disable the side panel that is used when another Wordle game
        is being solved (i.e. from the web), to set the letter colours after
        a guess. The 'enable' parameter will be set to True or False.  """

    if enable:
        _w1.lblColours['state'] = 'normal'
        _w1.cmdGreen['state'] = 'normal'
        _w1.cmdGold['state'] = 'normal'
        _w1.cmdGray['state'] = 'normal'
        _w1.cmdNext['state'] = 'normal'
        _w1.cmdGreen.config(background=green)
        _w1.cmdGold.config(background=gold)
        _w1.cmdGray.config(background=grey)
    else:
        _w1.lblColours['state'] = 'disable'
        _w1.cmdGreen['state'] = 'disable'
        _w1.cmdGold['state'] = 'disable'
        _w1.cmdGray['state'] = 'disable'
        _w1.cmdNext['state'] = 'disable'
        _w1.cmdGreen.config(background=btnDisabled)
        _w1.cmdGold.config(background=btnDisabled)
        _w1.cmdGray.config(background=btnDisabled)

#-------------------------------------------------------------------------------

def init_screen():
    """ Initialise the screen fields to their default values. This will be
        done on program startup and whenever the game is restarted. """

    # Set all the letter widgets to disabled, backgrounds white, text blue.
    for words in wordGrid:
        for letter in words:
            letter['state'] = 'disable'
            letter.configure(disabledbackground=white,
                             disabledforeground=blue,
                             highlightthickness=0)

    # Clear any entries from the letter variable fields.
    for line in varsGrid:
        for txtbox in line:
            txtbox.set('')

    # Set the keyboard buttons to the default background colour
    for key, button in keyboard.items():
        button.config(background=btnColour)

    global curr_word, curr_letter
    curr_word = 0
    curr_letter = 0

    # Clear the message area
    _w1.lblMessage.config(text='')

    setSidePanel(False)
    disableKeyboard()

    # Store a list of 5 sets, each holding all the lowercase alpha characters
    global letterSets
    letterSets = [set(string.ascii_lowercase) for _ in range(5)]

    wrongPos.clear()

#-------------------------------------------------------------------------------

def do_init():
    """ Do any initialisation stuff that we need before the screen is first
        displayed. Store the screen controls and text variables for each word
        in global lists. Store the keyboard buttons in a dictionary. """

    global wordGrid, varsGrid, keyboard

    # Screen controls for the word grid - a list of 6 sublists
    w1 = [_w1.txtWord11,_w1.txtWord12,_w1.txtWord13,_w1.txtWord14,_w1.txtWord15]
    w2 = [_w1.txtWord21,_w1.txtWord22,_w1.txtWord23,_w1.txtWord24,_w1.txtWord25]
    w3 = [_w1.txtWord31,_w1.txtWord32,_w1.txtWord33,_w1.txtWord34,_w1.txtWord35]
    w4 = [_w1.txtWord41,_w1.txtWord42,_w1.txtWord43,_w1.txtWord44,_w1.txtWord45]
    w5 = [_w1.txtWord51,_w1.txtWord52,_w1.txtWord53,_w1.txtWord54,_w1.txtWord55]
    w6 = [_w1.txtWord61,_w1.txtWord62,_w1.txtWord63,_w1.txtWord64,_w1.txtWord65]
    wordGrid.extend((w1,w2,w3,w4,w5,w6))

    # Textbox variables for the letters - a list of 6 sublists
    v1 = [_w1.vtxtWord11,_w1.vtxtWord12,_w1.vtxtWord13,_w1.vtxtWord14,_w1.vtxtWord15]
    v2 = [_w1.vtxtWord21,_w1.vtxtWord22,_w1.vtxtWord23,_w1.vtxtWord24,_w1.vtxtWord25]
    v3 = [_w1.vtxtWord31,_w1.vtxtWord32,_w1.vtxtWord33,_w1.vtxtWord34,_w1.vtxtWord35]
    v4 = [_w1.vtxtWord41,_w1.vtxtWord42,_w1.vtxtWord43,_w1.vtxtWord44,_w1.vtxtWord45]
    v5 = [_w1.vtxtWord51,_w1.vtxtWord52,_w1.vtxtWord53,_w1.vtxtWord54,_w1.vtxtWord55]
    v6 = [_w1.vtxtWord61,_w1.vtxtWord62,_w1.vtxtWord63,_w1.vtxtWord64,_w1.vtxtWord65]
    varsGrid.extend((v1,v2,v3,v4,v5,v6))

    # Keyboard buttons, key is a letter, value is the matching button control
    k1 = {'a':_w1.cmdA,'b':_w1.cmdB,'c':_w1.cmdC,'d':_w1.cmdD,'e':_w1.cmdE}
    k2 = {'f':_w1.cmdF,'g':_w1.cmdG,'h':_w1.cmdH,'i':_w1.cmdI,'j':_w1.cmdJ}
    k3 = {'k':_w1.cmdK,'l':_w1.cmdL,'m':_w1.cmdM,'n':_w1.cmdN,'o':_w1.cmdO}
    k4 = {'p':_w1.cmdP,'q':_w1.cmdQ,'r':_w1.cmdR,'s':_w1.cmdS,'t':_w1.cmdT}
    k5 = {'u':_w1.cmdU,'v':_w1.cmdV,'w':_w1.cmdW,'x':_w1.cmdX,'y':_w1.cmdY}
    k6 = {'z':_w1.cmdZ}
    keyboard.update(k1)
    keyboard.update(k2)
    keyboard.update(k3)
    keyboard.update(k4)
    keyboard.update(k5)
    keyboard.update(k6)

    _w1.ManAuto.set('Man')
    _top1.iconbitmap('wordpie.ico')

    # Bind these <Ctrl> key sequences to the root, so that they will be picked
    # up at any point in the program.
    root.bind('<Control-h>', key_pressed)
    root.bind('<Control-d>', key_pressed)

    # Update the word dictionary with the word scores, etc.
    wordpie.setupDataframe()

    init_screen()

#-------------------------------------------------------------------------------

def main(*args):
    """ Main entry point for the application. Mainly generated by PAGE. """

    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = wordpie_gui.WordPie(_top1)

    # Do any initialisation stuff before the main loop starts
    do_init()       # this line is our stuff, not PAGE.

    root.mainloop()

#-------------------------------------------------------------------------------

if __name__ == '__main__':
    wordpie_gui.start_up()

#-------------------------------------------------------------------------------